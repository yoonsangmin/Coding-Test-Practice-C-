//// 내 풀이
//#include <iostream>
//#include <vector>
//
//using namespace std;
//
//int solution(int n) {
//    if (n & 1)
//        return 0;
//
//    vector<long long> v = { 3 };
//
//    long long last_ver = 1;
//
//    for (int i = 2; i < n; i += 2)
//    {
//        v.push_back((v.back() * 3 + last_ver * 2) % 1000000007);
//        last_ver += v[v.size() - 2];
//    }
//
//    return v.back();
//}
//
//int main()
//{
//    cout << solution(6);
//
//    return 0;
//}

//// 다른 사람 풀이
//// 재귀 사용 - 조금 오래 걸림
//#include<map>
//#include<iostream>
//using namespace std;
//
//// 맵일 필요는 없음 - 배열도 가능할 듯
//map<int, int> cache{ {1,1}, {2,3} };
//
//int tiling(int n) {
//    if (n & 1) return 0;
//    
//    if (n > 3 && cache.find(n - 1) == cache.end())
//        // 재귀 함수를 사용
//        // n - 1까지 계산 - 점화식
//        // 원래는 이전값 * 3 을 하면 되는데 오른쪽 끝에 세로로 서있는 경우 다른 경우가 생김
//        // 그 추가적인 경우를 홀수 번째에 저장
//        // 세로로 있는 경우가 2칸 추가하기 전의 모든 경우의 수만큼 있고(n - 2, 그대로 추가한 경우)
//        // 그 중 n - 3에 저장한 값만큼 같은 쪽(위, 아래)에 세로 블럭이 붙어있는 경우 오른쪽에서 2, 3번째 붙어있는 세로 블럭을 눕힐 수 있음
//        cache[n - 1] = (tiling(n - 2) + cache[n - 3]) % 100000;
//    if (cache.find(n) == cache.end())
//        // 내 풀이랑 비슷 n을 계산할 때 cache[n - 1](홀수 번째는 답이 될 수 없고 계산을 보조하는 용도)는 n - 2 값에서 n - 3을 더한 값
//        // 즉, n일 때 추가할 수 있는 모든 경우 중에 오른쪽 끝에 세로로 서있는 블록이 있을 때 가능한 모든 경우의 수이다. - 위에 세로, 아래 세로 총 2가지
//        // tiling(n - 2)는 어차피 cache에서 찾아지면 연산을 하진 않지만 찾는 연산이 불필요하게 들어감 - 그냥 cache[n - 2] 써도 됨
//        cache[n] = (tiling(n - 2) + 2 * cache[n - 1]) % 100000;
//    return cache[n] % 100000;
//}
//
//int main()
//{
//    cout <<tiling(4);
//}
//// 수정
//#include<map>
//using namespace std;
//
//map<int, long long> cache{ {1,1}, {2,3} };
//
//int solution(int n) {
//    if (n & 1) return 0;
//    if (n > 3 && cache.find(n - 1) == cache.end())
//        cache[n - 1] = (solution(n - 2) + cache[n - 3]) % 1000000007;
//    if (cache.find(n) == cache.end())
//        cache[n] = (solution(n - 2) + 2 * cache[n - 1]) % 1000000007;
//    return cache[n] % 1000000007;
//}


// 쉬운 풀이
// ( n은 i * 2로 생각하시면 됩니다.)
// dp[i] = dp[i-1] * 3 +(dp[i-1] - dp[i-2]) -> dp[i-1] * 4 - dp[i-2]
// 모두 짝수 번째만 저장한 배열
// dp[i-1] - dp[i-2]이 가능한 이유 - i - 1 번째 값에서 i - 2 번째 값을 빼면
// 오른쪽 끝에 가로로 눞혀 만든 경우를 뺀 오른쪽 위든 아래든 세로 블럭이 있는 모든 경우가 나옴 - 당연한 것 가로로 3개 쌓은 블럭은 그냥 붙이기만 할 뿐이니 n - 2의 값과 같음
// 대신 모듈러 연산으로 값을 줄이기 때문에 음수가 나올 가능성이 있음
// temp = dp[i - 1] * 4 - dp[i - 2]; dp[i] = temp > 0 ? temp % 1, , , 007 : temp + 1, , , 007; 이런식으로 음수인 경우 1000000007을 더해줘야 함

// 다른 풀이
// dp[i] = dp[i-1] * 3, 여기에 +2를 해주고, i-2부터 1까지 모든 값을 두배해서 더해주기 = + (1 + dp[1] + ... + dp[i - 2]) * 2 를 해주면 됨 dp[0] = 1
// 왜 가능한가
// 2 곱하기 전을 보면 i - 2 까지 오른쪽 끝에 위쪽 또는 아래쪽으로 세로 블록으로 끝나는 경우의 수임
// 결국 내 풀이랑 비슷함 - 오른쪽 끝이 세로로 서있는 경우는 같은 세로 블럭이랑 맞았을 때 눕힐 수 있는 경우가 됨
// 위, 아래 두 방향이 가능하고 경우의 수는 같기 때문에 * 2
// 마지막에 따로 더해준 값은 세로로 붙이 있는 블럭을 눕혔을 때 가능한 경우(n - 2, n - 1 처럼 짝수와 홀수 사이에 끼인 경우)
// 세웠을 때 경우의 수는 일반적으로 dp[i - 1] * 3인 경우에 다 포함이 됨
// 그때 그때 새로 구하지 말고 따로 저장해 놓고 추가하면 될 듯

// 곱하기 3인 이유 - 길이가 2일 때 만들 수 있는 경우 3가지
// 이전 모든 경우에 오른쪽에 3가지 중 하나를 추가할 수 있기 때문
// ┌┬┐
// │││
// ├┴┤
// └─┘ 

// ┌─┐
// ├┬┤
// │││
// └┴┘

// ┌─┐
// ├─┤
// ├─┤
// └─┘

// 오른쪽 끝에 이런식으로 세로 블럭이 같은 방향에 맞게 끝나는 경우
// ┌┬┬┬┐
// │││││
// ├┴┼┴┤
// └─┴─┘ 

// 이런식으로 짝수 번째 세로 블럭과 홀수 번째 붙은 세로 블럭을 눕힌 경우가 생김
// ┌┬─┬┐
// │├─┤│
// ├┴┬┴┤
// └─┴─┘ 